{"ast":null,"code":"// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nfunction mockInternals() {\n  var _a, _b;\n  window.__TAURI_INTERNALS__ = (_a = window.__TAURI_INTERNALS__) !== null && _a !== void 0 ? _a : {};\n  window.__TAURI_EVENT_PLUGIN_INTERNALS__ = (_b = window.__TAURI_EVENT_PLUGIN_INTERNALS__) !== null && _b !== void 0 ? _b : {};\n}\n/**\n * Intercepts all IPC requests with the given mock handler.\n *\n * This function can be used when testing tauri frontend applications or when running the frontend in a Node.js context during static site generation.\n *\n * # Examples\n *\n * Testing setup using Vitest:\n * ```ts\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { invoke } from \"@tauri-apps/api/core\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked command\", () => {\n *  mockIPC((cmd, payload) => {\n *   switch (cmd) {\n *     case \"add\":\n *       return (payload.a as number) + (payload.b as number);\n *     default:\n *       break;\n *     }\n *  });\n *\n *  expect(invoke('add', { a: 12, b: 15 })).resolves.toBe(27);\n * })\n * ```\n *\n * The callback function can also return a Promise:\n * ```js\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { invoke } from \"@tauri-apps/api/core\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked command\", () => {\n *  mockIPC((cmd, payload) => {\n *   if(cmd === \"get_data\") {\n *    return fetch(\"https://example.com/data.json\")\n *      .then((response) => response.json())\n *   }\n *  });\n *\n *  expect(invoke('get_data')).resolves.toBe({ foo: 'bar' });\n * })\n * ```\n *\n * `listen` can also be mocked with direct calls to the `emit` function. This functionality is opt-in via the `shouldMockEvents` option:\n * ```js\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { emit, listen } from \"@tauri-apps/api/event\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked event\", () => {\n *  mockIPC(() => {}, { shouldMockEvents: true }); // enable event mocking\n *\n *  const eventHandler = vi.fn();\n *  listen('test-event', eventHandler); // typically in component setup or similar\n *\n *  emit('test-event', { foo: 'bar' });\n *  expect(eventHandler).toHaveBeenCalledWith({\n *    event: 'test-event',\n *    payload: { foo: 'bar' }\n *  });\n * })\n * ```\n * `emitTo` is currently **not** supported by this mock implementation.\n *\n * @since 1.0.0\n */\nfunction mockIPC(cb, options) {\n  mockInternals();\n  function isEventPluginInvoke(cmd) {\n    return cmd.startsWith('plugin:event|');\n  }\n  function handleEventPlugin(cmd, args) {\n    switch (cmd) {\n      case 'plugin:event|listen':\n        return handleListen(args);\n      case 'plugin:event|emit':\n        return handleEmit(args);\n      case 'plugin:event|unlisten':\n        return handleRemoveListener(args);\n    }\n  }\n  const listeners = new Map();\n  function handleListen(args) {\n    if (!listeners.has(args.event)) {\n      listeners.set(args.event, []);\n    }\n    listeners.get(args.event).push(args.handler);\n    return args.handler;\n  }\n  function handleEmit(args) {\n    const eventListeners = listeners.get(args.event) || [];\n    for (const handler of eventListeners) {\n      runCallback(handler, args);\n    }\n    return null;\n  }\n  function handleRemoveListener(args) {\n    const eventListeners = listeners.get(args.event);\n    if (eventListeners) {\n      const index = eventListeners.indexOf(args.id);\n      if (index !== -1) {\n        eventListeners.splice(index, 1);\n      }\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async function invoke(cmd, args, _options) {\n    if ((options === null || options === void 0 ? void 0 : options.shouldMockEvents) && isEventPluginInvoke(cmd)) {\n      return handleEventPlugin(cmd, args);\n    }\n    return cb(cmd, args);\n  }\n  const callbacks = new Map();\n  function registerCallback(callback, once = false) {\n    const identifier = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    callbacks.set(identifier, data => {\n      if (once) {\n        unregisterCallback(identifier);\n      }\n      return callback && callback(data);\n    });\n    return identifier;\n  }\n  function unregisterCallback(id) {\n    callbacks.delete(id);\n  }\n  function runCallback(id, data) {\n    const callback = callbacks.get(id);\n    if (callback) {\n      callback(data);\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(`[TAURI] Couldn't find callback id ${id}. This might happen when the app is reloaded while Rust is running an asynchronous operation.`);\n    }\n  }\n  function unregisterListener(event, id) {\n    unregisterCallback(id);\n  }\n  window.__TAURI_INTERNALS__.invoke = invoke;\n  window.__TAURI_INTERNALS__.transformCallback = registerCallback;\n  window.__TAURI_INTERNALS__.unregisterCallback = unregisterCallback;\n  window.__TAURI_INTERNALS__.runCallback = runCallback;\n  window.__TAURI_INTERNALS__.callbacks = callbacks;\n  window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener = unregisterListener;\n}\n/**\n * Mocks one or many window labels.\n * In non-tauri context it is required to call this function *before* using the `@tauri-apps/api/window` module.\n *\n * This function only mocks the *presence* of windows,\n * window properties (e.g. width and height) can be mocked like regular IPC calls using the `mockIPC` function.\n *\n * # Examples\n *\n * ```js\n * import { mockWindows } from \"@tauri-apps/api/mocks\";\n * import { getCurrentWindow } from \"@tauri-apps/api/window\";\n *\n * mockWindows(\"main\", \"second\", \"third\");\n *\n * const win = getCurrentWindow();\n *\n * win.label // \"main\"\n * ```\n *\n * ```js\n * import { mockWindows } from \"@tauri-apps/api/mocks\";\n *\n * mockWindows(\"main\", \"second\", \"third\");\n *\n * mockIPC((cmd, args) => {\n *  if (cmd === \"plugin:event|emit\") {\n *    console.log('emit event', args?.event, args?.payload);\n *  }\n * });\n *\n * const { emit } = await import(\"@tauri-apps/api/event\");\n * await emit('loaded'); // this will cause the mocked IPC handler to log to the console.\n * ```\n *\n * @param current Label of window this JavaScript context is running in.\n *\n * @since 1.0.0\n */\nfunction mockWindows(current, ..._additionalWindows) {\n  mockInternals();\n  window.__TAURI_INTERNALS__.metadata = {\n    currentWindow: {\n      label: current\n    },\n    currentWebview: {\n      windowLabel: current,\n      label: current\n    }\n  };\n}\n/**\n * Mock `convertFileSrc` function\n *\n *\n * @example\n * ```js\n * import { mockConvertFileSrc } from \"@tauri-apps/api/mocks\";\n * import { convertFileSrc } from \"@tauri-apps/api/core\";\n *\n * mockConvertFileSrc(\"windows\")\n *\n * const url = convertFileSrc(\"C:\\\\Users\\\\user\\\\file.txt\")\n * ```\n *\n * @param osName The operating system to mock, can be one of linux, macos, or windows\n *\n * @since 1.6.0\n */\nfunction mockConvertFileSrc(osName) {\n  mockInternals();\n  window.__TAURI_INTERNALS__.convertFileSrc = function (filePath, protocol = 'asset') {\n    const path = encodeURIComponent(filePath);\n    return osName === 'windows' ? `http://${protocol}.localhost/${path}` : `${protocol}://localhost/${path}`;\n  };\n}\n/**\n * Clears mocked functions/data injected by the other functions in this module.\n * When using a test runner that doesn't provide a fresh window object for each test, calling this function will reset tauri specific properties.\n *\n * # Example\n *\n * ```js\n * import { mockWindows, clearMocks } from \"@tauri-apps/api/mocks\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked windows\", () => {\n *    mockWindows(\"main\", \"second\", \"third\");\n *\n *    expect(window.__TAURI_INTERNALS__).toHaveProperty(\"metadata\")\n * })\n *\n * test(\"no mocked windows\", () => {\n *    expect(window.__TAURI_INTERNALS__).not.toHaveProperty(\"metadata\")\n * })\n * ```\n *\n * @since 1.0.0\n */\nfunction clearMocks() {\n  if (typeof window.__TAURI_INTERNALS__ !== 'object') {\n    return;\n  }\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.invoke;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.transformCallback;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.unregisterCallback;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.runCallback;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.callbacks;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.convertFileSrc;\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_INTERNALS__.metadata;\n  if (typeof window.__TAURI_EVENT_PLUGIN_INTERNALS__ !== 'object') {\n    return;\n  }\n  // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n  delete window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener;\n}\nexport { clearMocks, mockConvertFileSrc, mockIPC, mockWindows };","map":{"version":3,"names":["mockInternals","_a","_b","window","__TAURI_INTERNALS__","__TAURI_EVENT_PLUGIN_INTERNALS__","mockIPC","cb","options","isEventPluginInvoke","cmd","startsWith","handleEventPlugin","args","handleListen","handleEmit","handleRemoveListener","listeners","Map","has","event","set","get","push","handler","eventListeners","runCallback","index","indexOf","id","splice","invoke","_options","shouldMockEvents","callbacks","registerCallback","callback","once","identifier","crypto","getRandomValues","Uint32Array","data","unregisterCallback","delete","console","warn","unregisterListener","transformCallback","mockWindows","current","_additionalWindows","metadata","currentWindow","label","currentWebview","windowLabel","mockConvertFileSrc","osName","convertFileSrc","filePath","protocol","path","encodeURIComponent","clearMocks"],"sources":["C:/Users/lhaveman/email-generator/node_modules/@tauri-apps/api/mocks.js"],"sourcesContent":["// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nfunction mockInternals() {\n    var _a, _b;\n    window.__TAURI_INTERNALS__ = (_a = window.__TAURI_INTERNALS__) !== null && _a !== void 0 ? _a : {};\n    window.__TAURI_EVENT_PLUGIN_INTERNALS__ =\n        (_b = window.__TAURI_EVENT_PLUGIN_INTERNALS__) !== null && _b !== void 0 ? _b : {};\n}\n/**\n * Intercepts all IPC requests with the given mock handler.\n *\n * This function can be used when testing tauri frontend applications or when running the frontend in a Node.js context during static site generation.\n *\n * # Examples\n *\n * Testing setup using Vitest:\n * ```ts\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { invoke } from \"@tauri-apps/api/core\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked command\", () => {\n *  mockIPC((cmd, payload) => {\n *   switch (cmd) {\n *     case \"add\":\n *       return (payload.a as number) + (payload.b as number);\n *     default:\n *       break;\n *     }\n *  });\n *\n *  expect(invoke('add', { a: 12, b: 15 })).resolves.toBe(27);\n * })\n * ```\n *\n * The callback function can also return a Promise:\n * ```js\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { invoke } from \"@tauri-apps/api/core\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked command\", () => {\n *  mockIPC((cmd, payload) => {\n *   if(cmd === \"get_data\") {\n *    return fetch(\"https://example.com/data.json\")\n *      .then((response) => response.json())\n *   }\n *  });\n *\n *  expect(invoke('get_data')).resolves.toBe({ foo: 'bar' });\n * })\n * ```\n *\n * `listen` can also be mocked with direct calls to the `emit` function. This functionality is opt-in via the `shouldMockEvents` option:\n * ```js\n * import { mockIPC, clearMocks } from \"@tauri-apps/api/mocks\"\n * import { emit, listen } from \"@tauri-apps/api/event\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked event\", () => {\n *  mockIPC(() => {}, { shouldMockEvents: true }); // enable event mocking\n *\n *  const eventHandler = vi.fn();\n *  listen('test-event', eventHandler); // typically in component setup or similar\n *\n *  emit('test-event', { foo: 'bar' });\n *  expect(eventHandler).toHaveBeenCalledWith({\n *    event: 'test-event',\n *    payload: { foo: 'bar' }\n *  });\n * })\n * ```\n * `emitTo` is currently **not** supported by this mock implementation.\n *\n * @since 1.0.0\n */\nfunction mockIPC(cb, options) {\n    mockInternals();\n    function isEventPluginInvoke(cmd) {\n        return cmd.startsWith('plugin:event|');\n    }\n    function handleEventPlugin(cmd, args) {\n        switch (cmd) {\n            case 'plugin:event|listen':\n                return handleListen(args);\n            case 'plugin:event|emit':\n                return handleEmit(args);\n            case 'plugin:event|unlisten':\n                return handleRemoveListener(args);\n        }\n    }\n    const listeners = new Map();\n    function handleListen(args) {\n        if (!listeners.has(args.event)) {\n            listeners.set(args.event, []);\n        }\n        listeners.get(args.event).push(args.handler);\n        return args.handler;\n    }\n    function handleEmit(args) {\n        const eventListeners = listeners.get(args.event) || [];\n        for (const handler of eventListeners) {\n            runCallback(handler, args);\n        }\n        return null;\n    }\n    function handleRemoveListener(args) {\n        const eventListeners = listeners.get(args.event);\n        if (eventListeners) {\n            const index = eventListeners.indexOf(args.id);\n            if (index !== -1) {\n                eventListeners.splice(index, 1);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async function invoke(cmd, args, _options) {\n        if ((options === null || options === void 0 ? void 0 : options.shouldMockEvents) && isEventPluginInvoke(cmd)) {\n            return handleEventPlugin(cmd, args);\n        }\n        return cb(cmd, args);\n    }\n    const callbacks = new Map();\n    function registerCallback(callback, once = false) {\n        const identifier = window.crypto.getRandomValues(new Uint32Array(1))[0];\n        callbacks.set(identifier, (data) => {\n            if (once) {\n                unregisterCallback(identifier);\n            }\n            return callback && callback(data);\n        });\n        return identifier;\n    }\n    function unregisterCallback(id) {\n        callbacks.delete(id);\n    }\n    function runCallback(id, data) {\n        const callback = callbacks.get(id);\n        if (callback) {\n            callback(data);\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.warn(`[TAURI] Couldn't find callback id ${id}. This might happen when the app is reloaded while Rust is running an asynchronous operation.`);\n        }\n    }\n    function unregisterListener(event, id) {\n        unregisterCallback(id);\n    }\n    window.__TAURI_INTERNALS__.invoke = invoke;\n    window.__TAURI_INTERNALS__.transformCallback = registerCallback;\n    window.__TAURI_INTERNALS__.unregisterCallback = unregisterCallback;\n    window.__TAURI_INTERNALS__.runCallback = runCallback;\n    window.__TAURI_INTERNALS__.callbacks = callbacks;\n    window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener =\n        unregisterListener;\n}\n/**\n * Mocks one or many window labels.\n * In non-tauri context it is required to call this function *before* using the `@tauri-apps/api/window` module.\n *\n * This function only mocks the *presence* of windows,\n * window properties (e.g. width and height) can be mocked like regular IPC calls using the `mockIPC` function.\n *\n * # Examples\n *\n * ```js\n * import { mockWindows } from \"@tauri-apps/api/mocks\";\n * import { getCurrentWindow } from \"@tauri-apps/api/window\";\n *\n * mockWindows(\"main\", \"second\", \"third\");\n *\n * const win = getCurrentWindow();\n *\n * win.label // \"main\"\n * ```\n *\n * ```js\n * import { mockWindows } from \"@tauri-apps/api/mocks\";\n *\n * mockWindows(\"main\", \"second\", \"third\");\n *\n * mockIPC((cmd, args) => {\n *  if (cmd === \"plugin:event|emit\") {\n *    console.log('emit event', args?.event, args?.payload);\n *  }\n * });\n *\n * const { emit } = await import(\"@tauri-apps/api/event\");\n * await emit('loaded'); // this will cause the mocked IPC handler to log to the console.\n * ```\n *\n * @param current Label of window this JavaScript context is running in.\n *\n * @since 1.0.0\n */\nfunction mockWindows(current, ..._additionalWindows) {\n    mockInternals();\n    window.__TAURI_INTERNALS__.metadata = {\n        currentWindow: { label: current },\n        currentWebview: { windowLabel: current, label: current }\n    };\n}\n/**\n * Mock `convertFileSrc` function\n *\n *\n * @example\n * ```js\n * import { mockConvertFileSrc } from \"@tauri-apps/api/mocks\";\n * import { convertFileSrc } from \"@tauri-apps/api/core\";\n *\n * mockConvertFileSrc(\"windows\")\n *\n * const url = convertFileSrc(\"C:\\\\Users\\\\user\\\\file.txt\")\n * ```\n *\n * @param osName The operating system to mock, can be one of linux, macos, or windows\n *\n * @since 1.6.0\n */\nfunction mockConvertFileSrc(osName) {\n    mockInternals();\n    window.__TAURI_INTERNALS__.convertFileSrc = function (filePath, protocol = 'asset') {\n        const path = encodeURIComponent(filePath);\n        return osName === 'windows'\n            ? `http://${protocol}.localhost/${path}`\n            : `${protocol}://localhost/${path}`;\n    };\n}\n/**\n * Clears mocked functions/data injected by the other functions in this module.\n * When using a test runner that doesn't provide a fresh window object for each test, calling this function will reset tauri specific properties.\n *\n * # Example\n *\n * ```js\n * import { mockWindows, clearMocks } from \"@tauri-apps/api/mocks\"\n *\n * afterEach(() => {\n *    clearMocks()\n * })\n *\n * test(\"mocked windows\", () => {\n *    mockWindows(\"main\", \"second\", \"third\");\n *\n *    expect(window.__TAURI_INTERNALS__).toHaveProperty(\"metadata\")\n * })\n *\n * test(\"no mocked windows\", () => {\n *    expect(window.__TAURI_INTERNALS__).not.toHaveProperty(\"metadata\")\n * })\n * ```\n *\n * @since 1.0.0\n */\nfunction clearMocks() {\n    if (typeof window.__TAURI_INTERNALS__ !== 'object') {\n        return;\n    }\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.invoke;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.transformCallback;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.unregisterCallback;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.runCallback;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.callbacks;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.convertFileSrc;\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_INTERNALS__.metadata;\n    if (typeof window.__TAURI_EVENT_PLUGIN_INTERNALS__ !== 'object') {\n        return;\n    }\n    // @ts-expect-error \"The operand of a 'delete' operator must be optional.\" does not matter in this case\n    delete window.__TAURI_EVENT_PLUGIN_INTERNALS__.unregisterListener;\n}\n\nexport { clearMocks, mockConvertFileSrc, mockIPC, mockWindows };\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,aAAaA,CAAA,EAAG;EACrB,IAAIC,EAAE,EAAEC,EAAE;EACVC,MAAM,CAACC,mBAAmB,GAAG,CAACH,EAAE,GAAGE,MAAM,CAACC,mBAAmB,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;EAClGE,MAAM,CAACE,gCAAgC,GACnC,CAACH,EAAE,GAAGC,MAAM,CAACE,gCAAgC,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,OAAOA,CAACC,EAAE,EAAEC,OAAO,EAAE;EAC1BR,aAAa,CAAC,CAAC;EACf,SAASS,mBAAmBA,CAACC,GAAG,EAAE;IAC9B,OAAOA,GAAG,CAACC,UAAU,CAAC,eAAe,CAAC;EAC1C;EACA,SAASC,iBAAiBA,CAACF,GAAG,EAAEG,IAAI,EAAE;IAClC,QAAQH,GAAG;MACP,KAAK,qBAAqB;QACtB,OAAOI,YAAY,CAACD,IAAI,CAAC;MAC7B,KAAK,mBAAmB;QACpB,OAAOE,UAAU,CAACF,IAAI,CAAC;MAC3B,KAAK,uBAAuB;QACxB,OAAOG,oBAAoB,CAACH,IAAI,CAAC;IACzC;EACJ;EACA,MAAMI,SAAS,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC3B,SAASJ,YAAYA,CAACD,IAAI,EAAE;IACxB,IAAI,CAACI,SAAS,CAACE,GAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}