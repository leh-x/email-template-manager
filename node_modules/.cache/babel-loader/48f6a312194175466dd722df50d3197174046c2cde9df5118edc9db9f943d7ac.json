{"ast":null,"code":"import * as v from 'valibot';\nimport { invoke } from '@tauri-apps/api/core';\nimport { emit, listen } from '@tauri-apps/api/event';\nconst buildCmd = cmd => `plugin:clipboard|${cmd}`;\nconst buildEventUrl = event => `plugin:clipboard://${event}`;\nconst START_MONITOR_COMMAND = buildCmd(\"start_monitor\");\nconst STOP_MONITOR_COMMAND = buildCmd(\"stop_monitor\");\nconst SOMETHING_CHANGED = buildEventUrl(\"something-changed\");\nconst TEXT_CHANGED = buildEventUrl(\"text-changed\");\nconst HTML_CHANGED = buildEventUrl(\"html-changed\");\nconst RTF_CHANGED = buildEventUrl(\"rtf-changed\");\nconst FILES_CHANGED = buildEventUrl(\"files-changed\");\nconst IMAGE_CHANGED = buildEventUrl(\"image-changed\");\nconst IMAGE_BINARY_CHANGED = buildEventUrl(\"image-changed-binary\");\nconst IS_MONITOR_RUNNING_COMMAND = buildCmd(\"is_monitor_running\");\nconst HAS_TEXT_COMMAND = buildCmd(\"has_text\");\nconst HAS_IMAGE_COMMAND = buildCmd(\"has_image\");\nconst HAS_HTML_COMMAND = buildCmd(\"has_html\");\nconst HAS_RTF_COMMAND = buildCmd(\"has_rtf\");\nconst HAS_FILES_COMMAND = buildCmd(\"has_files\");\nconst AVAILABLE_TYPES_COMMAND = buildCmd(\"available_types\");\nconst WRITE_TEXT_COMMAND = buildCmd(\"write_text\");\nconst WRITE_HTML_COMMAND = buildCmd(\"write_html\");\nconst WRITE_HTML_AND_TEXT_COMMAND = buildCmd(\"write_html_and_text\");\nconst WRITE_RTF_COMMAND = buildCmd(\"write_rtf\");\nconst WRITE_FILES_URIS_COMMAND = buildCmd(\"write_files_uris\");\nconst WRITE_FILES_COMMAND = buildCmd(\"write_files\");\nconst CLEAR_COMMAND = buildCmd(\"clear\");\nconst READ_TEXT_COMMAND = buildCmd(\"read_text\");\nconst READ_HTML_COMMAND = buildCmd(\"read_html\");\nconst READ_RTF_COMMAND = buildCmd(\"read_rtf\");\nconst READ_FILES_COMMAND = buildCmd(\"read_files\");\nconst READ_FILES_URIS_COMMAND = buildCmd(\"read_files_uris\");\nconst READ_IMAGE_BINARY_COMMAND = buildCmd(\"read_image_binary\");\nconst READ_IMAGE_BASE64_COMMAND = buildCmd(\"read_image_base64\");\nconst WRITE_IMAGE_BINARY_COMMAND = buildCmd(\"write_image_binary\");\nconst WRITE_IMAGE_BASE64_COMMAND = buildCmd(\"write_image_base64\");\nconst CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT = buildEventUrl(\"clipboard-monitor/status\");\nconst MONITOR_UPDATE_EVENT = buildEventUrl(\"clipboard-monitor/update\");\nconst ClipboardChangedPayloadSchema = v.object({\n  value: v.string()\n});\nconst ClipboardBinaryChangedPayloadSchema = v.object({\n  value: v.array(v.number())\n});\nconst ClipboardChangedFilesPayloadSchema = v.object({\n  value: v.array(v.string())\n});\nfunction hasText() {\n  return invoke(HAS_TEXT_COMMAND);\n}\nfunction hasHTML() {\n  return invoke(HAS_HTML_COMMAND);\n}\nfunction hasRTF() {\n  return invoke(HAS_RTF_COMMAND);\n}\nfunction hasImage() {\n  return invoke(HAS_IMAGE_COMMAND);\n}\nfunction hasFiles() {\n  return invoke(HAS_FILES_COMMAND);\n}\nfunction writeText(text) {\n  return invoke(WRITE_TEXT_COMMAND, {\n    text\n  });\n}\nfunction writeHtml(html) {\n  return invoke(WRITE_HTML_COMMAND, {\n    html\n  });\n}\n/**\n * Write html and text to clipboard.\n * writeHtml API only writes html, readText will return nothing.\n * This API writes both html and text, so readText will return the text.\n */\nfunction writeHtmlAndText(html, text) {\n  return invoke(WRITE_HTML_AND_TEXT_COMMAND, {\n    html,\n    text\n  });\n}\nfunction writeRtf(rtf) {\n  return invoke(WRITE_RTF_COMMAND, {\n    rtf\n  });\n}\nfunction writeFilesURIs(filesUris) {\n  return invoke(WRITE_FILES_URIS_COMMAND, {\n    filesUris\n  });\n}\nfunction writeFiles(filesPaths) {\n  return invoke(WRITE_FILES_COMMAND, {\n    filesPaths\n  });\n}\nfunction clear() {\n  return invoke(CLEAR_COMMAND);\n}\nfunction readText() {\n  return invoke(READ_TEXT_COMMAND);\n}\nfunction readHtml() {\n  return invoke(READ_HTML_COMMAND);\n}\nfunction readRtf() {\n  return invoke(READ_RTF_COMMAND);\n}\nfunction readFiles() {\n  return invoke(READ_FILES_COMMAND);\n}\nfunction readFilesURIs() {\n  return invoke(READ_FILES_URIS_COMMAND);\n}\n/**\n * read clipboard image\n * @returns image in base64 string\n */\nfunction readImageBase64() {\n  return invoke(READ_IMAGE_BASE64_COMMAND);\n}\n// export const readImageBase64 = readImage;\n/**\n * Read clipboard image, get the data in binary format\n * int_array (Array<number>) is received from Tauri core, Uint8Array and Blob are transformed from int_array\n * @param format data type of returned value, \"int_array\" is the fastest\n * @returns\n */\nfunction readImageBinary(format) {\n  return invoke(READ_IMAGE_BINARY_COMMAND).then(img_arr => {\n    switch (format) {\n      case \"int_array\":\n        return img_arr;\n      case \"Uint8Array\":\n        return new Uint8Array(img_arr);\n      case \"Blob\":\n        return new Blob([new Uint8Array(img_arr)]);\n      default:\n        return img_arr;\n    }\n  });\n}\nfunction convertIntArrToUint8Array(intArr) {\n  return new Uint8Array(intArr);\n}\nfunction convertUint8ArrayToBlob(uintArr) {\n  return new Blob([uintArr]);\n}\n/**\n * Here is the transformation flow,\n * read clipboard image as Array<number> (int_array) -> int_array -> Uint8Array -> Blob -> ObjectURL\n * There are many layers which could make this function slow for large images.\n * @returns ObjectURL for clipboard image\n */\nfunction readImageObjectURL() {\n  return readImageBinary(\"Blob\").then(blob => {\n    return URL.createObjectURL(blob);\n  });\n}\n/**\n * write image to clipboard\n * @param data image data in base64 encoded string\n * @returns Promise<void>\n */\nfunction writeImageBase64(base64) {\n  return invoke(WRITE_IMAGE_BASE64_COMMAND, {\n    base64Image: base64\n  });\n}\nfunction writeImageBinary(bytes) {\n  return invoke(WRITE_IMAGE_BINARY_COMMAND, {\n    bytes: bytes\n  });\n}\n/**\n * @deprecated since version v0.5.x\n * Brute force listen to clipboard text update.\n * Detect update by comparing current value with previous value every delay ms.\n * When there is a update, \"plugin:clipboard://text-changed\" is emitted.\n * You still need to listen to the event.\n *\n * @param delay check interval delay\n * @returns a stop running function that can be called when component unmounts\n */\nfunction startBruteForceTextMonitor(delay = 500) {\n  let prevText = \"\";\n  let active = true; // whether the listener should be running\n  setTimeout(async function x() {\n    try {\n      const text = await readText();\n      if (prevText !== text) {\n        await emit(TEXT_CHANGED, {\n          value: text\n        });\n      }\n      prevText = text;\n    } catch (error) {}\n    if (active) setTimeout(x, delay);\n  }, delay);\n  return function () {\n    active = false;\n  };\n}\n/**\n * @deprecated since version v0.5.x\n * Brute force monitor clipboard image update by comparing current value with previous value.\n * When there is a update, \"plugin:clipboard://image-changed\" is emitted.\n * You still need to listen to the event.\n *\n * @param delay check interval delay\n * @returns stop running function that can be called to stop the monitor\n */\nfunction startBruteForceImageMonitor(delay = 1000) {\n  let prevImg = \"\";\n  let active = true; // whether the listener should be running\n  setTimeout(async function x() {\n    try {\n      const img = await readImageBase64();\n      if (prevImg !== img) {\n        await emit(IMAGE_CHANGED, {\n          value: img\n        });\n      }\n      prevImg = img;\n    } catch (error) {\n      // ! when there is no image in clipboard, there may be error thrown, we ignore the error\n    }\n    if (active) setTimeout(x, delay);\n  }, delay);\n  return function () {\n    active = false;\n  };\n}\nfunction getAvailableTypes() {\n  return invoke(AVAILABLE_TYPES_COMMAND);\n}\n/**\n * Listen to \"plugin:clipboard://clipboard-monitor/update\" from Tauri core.\n * The corresponding clipboard type event will be emitted when there is clipboard update.\n * @param listenTypes types of clipboard data to listen to\n * @returns unlisten function\n */\nfunction listenToClipboard(listenTypes = {\n  text: true,\n  html: true,\n  rtf: true,\n  image: true,\n  imageBinary: false,\n  files: true\n}) {\n  return listen(MONITOR_UPDATE_EVENT, async e => {\n    if (e.payload === \"clipboard update\") {\n      const hasData = await Promise.all([hasFiles(), hasImage(), hasHTML(), hasRTF(), hasText()]);\n      const flags = {\n        files: hasData[0],\n        image: hasData[1],\n        imageBinary: hasData[1],\n        html: hasData[2],\n        rtf: hasData[3],\n        text: hasData[4]\n      };\n      await emit(SOMETHING_CHANGED, flags);\n      if (listenTypes.files && flags.files) {\n        const files = await readFiles();\n        if (files && files.length > 0) {\n          await emit(FILES_CHANGED, {\n            value: files\n          });\n        }\n        // flags.files = true;\n        return; // ! this return is necessary, copying files also update clipboard text, but we don't want text update to be triggered\n      }\n      if (listenTypes.image && flags.image) {\n        const img = await readImageBase64();\n        if (img) await emit(IMAGE_CHANGED, {\n          value: img\n        });\n        // flags.image = true;\n      }\n      if (listenTypes.imageBinary && flags.imageBinary) {\n        const img = await readImageBinary(\"int_array\");\n        if (img) await emit(IMAGE_BINARY_CHANGED, {\n          value: img\n        });\n        // flags.imageBinary = true;\n      }\n      if (listenTypes.html && flags.html) {\n        await emit(HTML_CHANGED, {\n          value: await readHtml()\n        });\n        // flags.html = true;\n      }\n      if (listenTypes.rtf && flags.rtf) {\n        await emit(RTF_CHANGED, {\n          value: await readRtf()\n        });\n        // flags.rtf = true;\n      }\n      if (listenTypes.text && flags.text) {\n        await emit(TEXT_CHANGED, {\n          value: await readText()\n        });\n        // flags.text = true;\n      }\n      // when clear() is called, this error is thrown, let ignore it\n      // if (!success) {\n      //   throw new Error(\"Unexpected Error: No proper clipboard type\");\n      // }\n    }\n  });\n}\n/**\n * This listen to clipboard monitor update event, and trigger the callback function.\n * However from this event we don't know whether it's text or image, no real data is returned.\n * Use with listenToClipboard function.\n * @param cb callback\n * @returns unlisten function\n */\nfunction onClipboardUpdate(cb) {\n  return listen(MONITOR_UPDATE_EVENT, cb);\n}\nasync function onTextUpdate(cb) {\n  return await listen(TEXT_CHANGED, event => {\n    const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n    cb(text);\n  });\n}\n/**\n * Listen to clipboard update event and get the updated types in a callback.\n * This listener tells you what types of data are updated.\n * This relies on `listenToClipboard()` who emits events this function listens to.\n * You can run `listenToClipboard()` or `startListening()` before calling this function.\n * When HTML is copied, this will be passed to callback: {files: false, image: false, html: true, rtf: false, text: true}\n * @param cb\n * @returns\n */\nfunction onSomethingUpdate(cb) {\n  return listen(SOMETHING_CHANGED, event => {\n    cb(event.payload);\n  });\n}\nfunction onHTMLUpdate(cb) {\n  return listen(HTML_CHANGED, event => {\n    const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n    cb(text);\n  });\n}\nfunction onRTFUpdate(cb) {\n  return listen(RTF_CHANGED, event => {\n    const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n    cb(text);\n  });\n}\nfunction onFilesUpdate(cb) {\n  return listen(FILES_CHANGED, event => {\n    const files = v.parse(ClipboardChangedFilesPayloadSchema, event.payload).value;\n    cb(files);\n  });\n}\nfunction onImageUpdate(cb) {\n  return listen(IMAGE_CHANGED, event => {\n    const base64ImageStr = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n    cb(base64ImageStr);\n  });\n}\nfunction onImageBinaryUpdate(cb) {\n  return listen(IMAGE_BINARY_CHANGED, event => {\n    cb(v.parse(ClipboardBinaryChangedPayloadSchema, event.payload).value);\n  });\n}\n/**\n * Used to check the status of clipboard monitor\n * @returns Whether the monitor is running\n */\nfunction isMonitorRunning() {\n  return invoke(IS_MONITOR_RUNNING_COMMAND).then(res => v.parse(v.boolean(), res));\n}\n/**\n * Start running mointor thread in Tauri core. This feature is added in v0.5.x.\n * Before v0.5.x, the monitor is started during setup when app starts.\n * After v0.5.x, this function must be called first to start monitor.\n * After monitor is started, events \"plugin:clipboard://clipboard-monitor/update\" will be emitted when there is clipboard update.\n * \"plugin:clipboard://clipboard-monitor/status\" event is also emitted when monitor status updates\n * Still have to listen to these events.\n */\nfunction startMonitor() {\n  return invoke(START_MONITOR_COMMAND);\n}\n/**\n * Stop clipboard monitor thread.\n */\nfunction stopMonitor() {\n  return invoke(STOP_MONITOR_COMMAND);\n}\n/**\n * Listen to monitor status update. Instead of calling isMonitorRunning to get status of monitor,\n * \"plugin:clipboard://clipboard-monitor/status\" event is emitted from Tauri core when monitor status updates.\n * @param cb callback to be called when there is monitor status update\n */\nasync function listenToMonitorStatusUpdate(cb) {\n  return await listen(CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT, event => {\n    const newStatus = v.parse(v.boolean(), event.payload);\n    cb(newStatus);\n  });\n}\nfunction startListening(listenTypes = {\n  text: true,\n  html: true,\n  rtf: true,\n  image: true,\n  imageBinary: false,\n  files: true\n}) {\n  return startMonitor().then(() => listenToClipboard(listenTypes)).then(unlistenClipboard => {\n    // return an unlisten function that stop listening to clipboard update and stop the monitor\n    return async () => {\n      unlistenClipboard();\n      await stopMonitor();\n    };\n  });\n}\nvar api = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AVAILABLE_TYPES_COMMAND: AVAILABLE_TYPES_COMMAND,\n  CLEAR_COMMAND: CLEAR_COMMAND,\n  CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT: CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT,\n  ClipboardBinaryChangedPayloadSchema: ClipboardBinaryChangedPayloadSchema,\n  ClipboardChangedFilesPayloadSchema: ClipboardChangedFilesPayloadSchema,\n  ClipboardChangedPayloadSchema: ClipboardChangedPayloadSchema,\n  FILES_CHANGED: FILES_CHANGED,\n  HAS_FILES_COMMAND: HAS_FILES_COMMAND,\n  HAS_HTML_COMMAND: HAS_HTML_COMMAND,\n  HAS_IMAGE_COMMAND: HAS_IMAGE_COMMAND,\n  HAS_RTF_COMMAND: HAS_RTF_COMMAND,\n  HAS_TEXT_COMMAND: HAS_TEXT_COMMAND,\n  HTML_CHANGED: HTML_CHANGED,\n  IMAGE_BINARY_CHANGED: IMAGE_BINARY_CHANGED,\n  IMAGE_CHANGED: IMAGE_CHANGED,\n  IS_MONITOR_RUNNING_COMMAND: IS_MONITOR_RUNNING_COMMAND,\n  MONITOR_UPDATE_EVENT: MONITOR_UPDATE_EVENT,\n  READ_FILES_COMMAND: READ_FILES_COMMAND,\n  READ_FILES_URIS_COMMAND: READ_FILES_URIS_COMMAND,\n  READ_HTML_COMMAND: READ_HTML_COMMAND,\n  READ_IMAGE_BASE64_COMMAND: READ_IMAGE_BASE64_COMMAND,\n  READ_IMAGE_BINARY_COMMAND: READ_IMAGE_BINARY_COMMAND,\n  READ_RTF_COMMAND: READ_RTF_COMMAND,\n  READ_TEXT_COMMAND: READ_TEXT_COMMAND,\n  RTF_CHANGED: RTF_CHANGED,\n  SOMETHING_CHANGED: SOMETHING_CHANGED,\n  START_MONITOR_COMMAND: START_MONITOR_COMMAND,\n  STOP_MONITOR_COMMAND: STOP_MONITOR_COMMAND,\n  TEXT_CHANGED: TEXT_CHANGED,\n  WRITE_FILES_COMMAND: WRITE_FILES_COMMAND,\n  WRITE_FILES_URIS_COMMAND: WRITE_FILES_URIS_COMMAND,\n  WRITE_HTML_AND_TEXT_COMMAND: WRITE_HTML_AND_TEXT_COMMAND,\n  WRITE_HTML_COMMAND: WRITE_HTML_COMMAND,\n  WRITE_IMAGE_BASE64_COMMAND: WRITE_IMAGE_BASE64_COMMAND,\n  WRITE_IMAGE_BINARY_COMMAND: WRITE_IMAGE_BINARY_COMMAND,\n  WRITE_RTF_COMMAND: WRITE_RTF_COMMAND,\n  WRITE_TEXT_COMMAND: WRITE_TEXT_COMMAND,\n  clear: clear,\n  convertIntArrToUint8Array: convertIntArrToUint8Array,\n  convertUint8ArrayToBlob: convertUint8ArrayToBlob,\n  getAvailableTypes: getAvailableTypes,\n  hasFiles: hasFiles,\n  hasHTML: hasHTML,\n  hasImage: hasImage,\n  hasRTF: hasRTF,\n  hasText: hasText,\n  isMonitorRunning: isMonitorRunning,\n  listenToClipboard: listenToClipboard,\n  listenToMonitorStatusUpdate: listenToMonitorStatusUpdate,\n  onClipboardUpdate: onClipboardUpdate,\n  onFilesUpdate: onFilesUpdate,\n  onHTMLUpdate: onHTMLUpdate,\n  onImageBinaryUpdate: onImageBinaryUpdate,\n  onImageUpdate: onImageUpdate,\n  onRTFUpdate: onRTFUpdate,\n  onSomethingUpdate: onSomethingUpdate,\n  onTextUpdate: onTextUpdate,\n  readFiles: readFiles,\n  readFilesURIs: readFilesURIs,\n  readHtml: readHtml,\n  readImageBase64: readImageBase64,\n  readImageBinary: readImageBinary,\n  readImageObjectURL: readImageObjectURL,\n  readRtf: readRtf,\n  readText: readText,\n  startBruteForceImageMonitor: startBruteForceImageMonitor,\n  startBruteForceTextMonitor: startBruteForceTextMonitor,\n  startListening: startListening,\n  startMonitor: startMonitor,\n  stopMonitor: stopMonitor,\n  writeFiles: writeFiles,\n  writeFilesURIs: writeFilesURIs,\n  writeHtml: writeHtml,\n  writeHtmlAndText: writeHtmlAndText,\n  writeImageBase64: writeImageBase64,\n  writeImageBinary: writeImageBinary,\n  writeRtf: writeRtf,\n  writeText: writeText\n});\nexport { AVAILABLE_TYPES_COMMAND, CLEAR_COMMAND, CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT, ClipboardBinaryChangedPayloadSchema, ClipboardChangedFilesPayloadSchema, ClipboardChangedPayloadSchema, FILES_CHANGED, HAS_FILES_COMMAND, HAS_HTML_COMMAND, HAS_IMAGE_COMMAND, HAS_RTF_COMMAND, HAS_TEXT_COMMAND, HTML_CHANGED, IMAGE_BINARY_CHANGED, IMAGE_CHANGED, IS_MONITOR_RUNNING_COMMAND, MONITOR_UPDATE_EVENT, READ_FILES_COMMAND, READ_FILES_URIS_COMMAND, READ_HTML_COMMAND, READ_IMAGE_BASE64_COMMAND, READ_IMAGE_BINARY_COMMAND, READ_RTF_COMMAND, READ_TEXT_COMMAND, RTF_CHANGED, SOMETHING_CHANGED, START_MONITOR_COMMAND, STOP_MONITOR_COMMAND, TEXT_CHANGED, WRITE_FILES_COMMAND, WRITE_FILES_URIS_COMMAND, WRITE_HTML_AND_TEXT_COMMAND, WRITE_HTML_COMMAND, WRITE_IMAGE_BASE64_COMMAND, WRITE_IMAGE_BINARY_COMMAND, WRITE_RTF_COMMAND, WRITE_TEXT_COMMAND, clear, convertIntArrToUint8Array, convertUint8ArrayToBlob, api as default, getAvailableTypes, hasFiles, hasHTML, hasImage, hasRTF, hasText, isMonitorRunning, listenToClipboard, listenToMonitorStatusUpdate, onClipboardUpdate, onFilesUpdate, onHTMLUpdate, onImageBinaryUpdate, onImageUpdate, onRTFUpdate, onSomethingUpdate, onTextUpdate, readFiles, readFilesURIs, readHtml, readImageBase64, readImageBinary, readImageObjectURL, readRtf, readText, startBruteForceImageMonitor, startBruteForceTextMonitor, startListening, startMonitor, stopMonitor, writeFiles, writeFilesURIs, writeHtml, writeHtmlAndText, writeImageBase64, writeImageBinary, writeRtf, writeText };","map":{"version":3,"names":["v","invoke","emit","listen","buildCmd","cmd","buildEventUrl","event","START_MONITOR_COMMAND","STOP_MONITOR_COMMAND","SOMETHING_CHANGED","TEXT_CHANGED","HTML_CHANGED","RTF_CHANGED","FILES_CHANGED","IMAGE_CHANGED","IMAGE_BINARY_CHANGED","IS_MONITOR_RUNNING_COMMAND","HAS_TEXT_COMMAND","HAS_IMAGE_COMMAND","HAS_HTML_COMMAND","HAS_RTF_COMMAND","HAS_FILES_COMMAND","AVAILABLE_TYPES_COMMAND","WRITE_TEXT_COMMAND","WRITE_HTML_COMMAND","WRITE_HTML_AND_TEXT_COMMAND","WRITE_RTF_COMMAND","WRITE_FILES_URIS_COMMAND","WRITE_FILES_COMMAND","CLEAR_COMMAND","READ_TEXT_COMMAND","READ_HTML_COMMAND","READ_RTF_COMMAND","READ_FILES_COMMAND","READ_FILES_URIS_COMMAND","READ_IMAGE_BINARY_COMMAND","READ_IMAGE_BASE64_COMMAND","WRITE_IMAGE_BINARY_COMMAND","WRITE_IMAGE_BASE64_COMMAND","CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT","MONITOR_UPDATE_EVENT","ClipboardChangedPayloadSchema","object","value","string","ClipboardBinaryChangedPayloadSchema","array","number","ClipboardChangedFilesPayloadSchema","hasText","hasHTML","hasRTF","hasImage","hasFiles","writeText","text","writeHtml","html","writeHtmlAndText","writeRtf","rtf","writeFilesURIs","filesUris","writeFiles","filesPaths","clear","readText","readHtml","readRtf","readFiles","readFilesURIs","readImageBase64","readImageBinary","format","then","img_arr","Uint8Array","Blob","convertIntArrToUint8Array","intArr","convertUint8ArrayToBlob","uintArr","readImageObjectURL","blob","URL","createObjectURL","writeImageBase64","base64","base64Image","writeImageBinary","bytes","startBruteForceTextMonitor","delay","prevText","active","setTimeout","x","error","startBruteForceImageMonitor","prevImg","img","getAvailableTypes","listenToClipboard","listenTypes","image","imageBinary","files","e","payload","hasData","Promise","all","flags","length","onClipboardUpdate","cb","onTextUpdate","parse","onSomethingUpdate","onHTMLUpdate","onRTFUpdate","onFilesUpdate","onImageUpdate","base64ImageStr","onImageBinaryUpdate","isMonitorRunning","res","boolean","startMonitor","stopMonitor","listenToMonitorStatusUpdate","newStatus","startListening","unlistenClipboard","api","Object","freeze","__proto__","default"],"sources":["C:/Users/lhaveman/email-generator/node_modules/tauri-plugin-clipboard-api/dist-js/index.js"],"sourcesContent":["import * as v from 'valibot';\nimport { invoke } from '@tauri-apps/api/core';\nimport { emit, listen } from '@tauri-apps/api/event';\n\nconst buildCmd = (cmd) => `plugin:clipboard|${cmd}`;\nconst buildEventUrl = (event) => `plugin:clipboard://${event}`;\nconst START_MONITOR_COMMAND = buildCmd(\"start_monitor\");\nconst STOP_MONITOR_COMMAND = buildCmd(\"stop_monitor\");\nconst SOMETHING_CHANGED = buildEventUrl(\"something-changed\");\nconst TEXT_CHANGED = buildEventUrl(\"text-changed\");\nconst HTML_CHANGED = buildEventUrl(\"html-changed\");\nconst RTF_CHANGED = buildEventUrl(\"rtf-changed\");\nconst FILES_CHANGED = buildEventUrl(\"files-changed\");\nconst IMAGE_CHANGED = buildEventUrl(\"image-changed\");\nconst IMAGE_BINARY_CHANGED = buildEventUrl(\"image-changed-binary\");\nconst IS_MONITOR_RUNNING_COMMAND = buildCmd(\"is_monitor_running\");\nconst HAS_TEXT_COMMAND = buildCmd(\"has_text\");\nconst HAS_IMAGE_COMMAND = buildCmd(\"has_image\");\nconst HAS_HTML_COMMAND = buildCmd(\"has_html\");\nconst HAS_RTF_COMMAND = buildCmd(\"has_rtf\");\nconst HAS_FILES_COMMAND = buildCmd(\"has_files\");\nconst AVAILABLE_TYPES_COMMAND = buildCmd(\"available_types\");\nconst WRITE_TEXT_COMMAND = buildCmd(\"write_text\");\nconst WRITE_HTML_COMMAND = buildCmd(\"write_html\");\nconst WRITE_HTML_AND_TEXT_COMMAND = buildCmd(\"write_html_and_text\");\nconst WRITE_RTF_COMMAND = buildCmd(\"write_rtf\");\nconst WRITE_FILES_URIS_COMMAND = buildCmd(\"write_files_uris\");\nconst WRITE_FILES_COMMAND = buildCmd(\"write_files\");\nconst CLEAR_COMMAND = buildCmd(\"clear\");\nconst READ_TEXT_COMMAND = buildCmd(\"read_text\");\nconst READ_HTML_COMMAND = buildCmd(\"read_html\");\nconst READ_RTF_COMMAND = buildCmd(\"read_rtf\");\nconst READ_FILES_COMMAND = buildCmd(\"read_files\");\nconst READ_FILES_URIS_COMMAND = buildCmd(\"read_files_uris\");\nconst READ_IMAGE_BINARY_COMMAND = buildCmd(\"read_image_binary\");\nconst READ_IMAGE_BASE64_COMMAND = buildCmd(\"read_image_base64\");\nconst WRITE_IMAGE_BINARY_COMMAND = buildCmd(\"write_image_binary\");\nconst WRITE_IMAGE_BASE64_COMMAND = buildCmd(\"write_image_base64\");\nconst CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT = buildEventUrl(\"clipboard-monitor/status\");\nconst MONITOR_UPDATE_EVENT = buildEventUrl(\"clipboard-monitor/update\");\nconst ClipboardChangedPayloadSchema = v.object({ value: v.string() });\nconst ClipboardBinaryChangedPayloadSchema = v.object({\n    value: v.array(v.number())\n});\nconst ClipboardChangedFilesPayloadSchema = v.object({\n    value: v.array(v.string())\n});\nfunction hasText() {\n    return invoke(HAS_TEXT_COMMAND);\n}\nfunction hasHTML() {\n    return invoke(HAS_HTML_COMMAND);\n}\nfunction hasRTF() {\n    return invoke(HAS_RTF_COMMAND);\n}\nfunction hasImage() {\n    return invoke(HAS_IMAGE_COMMAND);\n}\nfunction hasFiles() {\n    return invoke(HAS_FILES_COMMAND);\n}\nfunction writeText(text) {\n    return invoke(WRITE_TEXT_COMMAND, { text });\n}\nfunction writeHtml(html) {\n    return invoke(WRITE_HTML_COMMAND, { html });\n}\n/**\n * Write html and text to clipboard.\n * writeHtml API only writes html, readText will return nothing.\n * This API writes both html and text, so readText will return the text.\n */\nfunction writeHtmlAndText(html, text) {\n    return invoke(WRITE_HTML_AND_TEXT_COMMAND, { html, text });\n}\nfunction writeRtf(rtf) {\n    return invoke(WRITE_RTF_COMMAND, { rtf });\n}\nfunction writeFilesURIs(filesUris) {\n    return invoke(WRITE_FILES_URIS_COMMAND, { filesUris });\n}\nfunction writeFiles(filesPaths) {\n    return invoke(WRITE_FILES_COMMAND, { filesPaths });\n}\nfunction clear() {\n    return invoke(CLEAR_COMMAND);\n}\nfunction readText() {\n    return invoke(READ_TEXT_COMMAND);\n}\nfunction readHtml() {\n    return invoke(READ_HTML_COMMAND);\n}\nfunction readRtf() {\n    return invoke(READ_RTF_COMMAND);\n}\nfunction readFiles() {\n    return invoke(READ_FILES_COMMAND);\n}\nfunction readFilesURIs() {\n    return invoke(READ_FILES_URIS_COMMAND);\n}\n/**\n * read clipboard image\n * @returns image in base64 string\n */\nfunction readImageBase64() {\n    return invoke(READ_IMAGE_BASE64_COMMAND);\n}\n// export const readImageBase64 = readImage;\n/**\n * Read clipboard image, get the data in binary format\n * int_array (Array<number>) is received from Tauri core, Uint8Array and Blob are transformed from int_array\n * @param format data type of returned value, \"int_array\" is the fastest\n * @returns\n */\nfunction readImageBinary(format) {\n    return invoke(READ_IMAGE_BINARY_COMMAND).then((img_arr) => {\n        switch (format) {\n            case \"int_array\":\n                return img_arr;\n            case \"Uint8Array\":\n                return new Uint8Array(img_arr);\n            case \"Blob\":\n                return new Blob([new Uint8Array(img_arr)]);\n            default:\n                return img_arr;\n        }\n    });\n}\nfunction convertIntArrToUint8Array(intArr) {\n    return new Uint8Array(intArr);\n}\nfunction convertUint8ArrayToBlob(uintArr) {\n    return new Blob([uintArr]);\n}\n/**\n * Here is the transformation flow,\n * read clipboard image as Array<number> (int_array) -> int_array -> Uint8Array -> Blob -> ObjectURL\n * There are many layers which could make this function slow for large images.\n * @returns ObjectURL for clipboard image\n */\nfunction readImageObjectURL() {\n    return readImageBinary(\"Blob\").then((blob) => {\n        return URL.createObjectURL(blob);\n    });\n}\n/**\n * write image to clipboard\n * @param data image data in base64 encoded string\n * @returns Promise<void>\n */\nfunction writeImageBase64(base64) {\n    return invoke(WRITE_IMAGE_BASE64_COMMAND, { base64Image: base64 });\n}\nfunction writeImageBinary(bytes) {\n    return invoke(WRITE_IMAGE_BINARY_COMMAND, { bytes: bytes });\n}\n/**\n * @deprecated since version v0.5.x\n * Brute force listen to clipboard text update.\n * Detect update by comparing current value with previous value every delay ms.\n * When there is a update, \"plugin:clipboard://text-changed\" is emitted.\n * You still need to listen to the event.\n *\n * @param delay check interval delay\n * @returns a stop running function that can be called when component unmounts\n */\nfunction startBruteForceTextMonitor(delay = 500) {\n    let prevText = \"\";\n    let active = true; // whether the listener should be running\n    setTimeout(async function x() {\n        try {\n            const text = await readText();\n            if (prevText !== text) {\n                await emit(TEXT_CHANGED, { value: text });\n            }\n            prevText = text;\n        }\n        catch (error) { }\n        if (active)\n            setTimeout(x, delay);\n    }, delay);\n    return function () {\n        active = false;\n    };\n}\n/**\n * @deprecated since version v0.5.x\n * Brute force monitor clipboard image update by comparing current value with previous value.\n * When there is a update, \"plugin:clipboard://image-changed\" is emitted.\n * You still need to listen to the event.\n *\n * @param delay check interval delay\n * @returns stop running function that can be called to stop the monitor\n */\nfunction startBruteForceImageMonitor(delay = 1000) {\n    let prevImg = \"\";\n    let active = true; // whether the listener should be running\n    setTimeout(async function x() {\n        try {\n            const img = await readImageBase64();\n            if (prevImg !== img) {\n                await emit(IMAGE_CHANGED, { value: img });\n            }\n            prevImg = img;\n        }\n        catch (error) {\n            // ! when there is no image in clipboard, there may be error thrown, we ignore the error\n        }\n        if (active)\n            setTimeout(x, delay);\n    }, delay);\n    return function () {\n        active = false;\n    };\n}\nfunction getAvailableTypes() {\n    return invoke(AVAILABLE_TYPES_COMMAND);\n}\n/**\n * Listen to \"plugin:clipboard://clipboard-monitor/update\" from Tauri core.\n * The corresponding clipboard type event will be emitted when there is clipboard update.\n * @param listenTypes types of clipboard data to listen to\n * @returns unlisten function\n */\nfunction listenToClipboard(listenTypes = {\n    text: true,\n    html: true,\n    rtf: true,\n    image: true,\n    imageBinary: false,\n    files: true\n}) {\n    return listen(MONITOR_UPDATE_EVENT, async (e) => {\n        if (e.payload === \"clipboard update\") {\n            const hasData = await Promise.all([hasFiles(), hasImage(), hasHTML(), hasRTF(), hasText()]);\n            const flags = {\n                files: hasData[0],\n                image: hasData[1],\n                imageBinary: hasData[1],\n                html: hasData[2],\n                rtf: hasData[3],\n                text: hasData[4]\n            };\n            await emit(SOMETHING_CHANGED, flags);\n            if (listenTypes.files && flags.files) {\n                const files = await readFiles();\n                if (files && files.length > 0) {\n                    await emit(FILES_CHANGED, { value: files });\n                }\n                // flags.files = true;\n                return; // ! this return is necessary, copying files also update clipboard text, but we don't want text update to be triggered\n            }\n            if (listenTypes.image && flags.image) {\n                const img = await readImageBase64();\n                if (img)\n                    await emit(IMAGE_CHANGED, { value: img });\n                // flags.image = true;\n            }\n            if (listenTypes.imageBinary && flags.imageBinary) {\n                const img = await readImageBinary(\"int_array\");\n                if (img)\n                    await emit(IMAGE_BINARY_CHANGED, { value: img });\n                // flags.imageBinary = true;\n            }\n            if (listenTypes.html && flags.html) {\n                await emit(HTML_CHANGED, { value: await readHtml() });\n                // flags.html = true;\n            }\n            if (listenTypes.rtf && flags.rtf) {\n                await emit(RTF_CHANGED, { value: await readRtf() });\n                // flags.rtf = true;\n            }\n            if (listenTypes.text && flags.text) {\n                await emit(TEXT_CHANGED, { value: await readText() });\n                // flags.text = true;\n            }\n            // when clear() is called, this error is thrown, let ignore it\n            // if (!success) {\n            //   throw new Error(\"Unexpected Error: No proper clipboard type\");\n            // }\n        }\n    });\n}\n/**\n * This listen to clipboard monitor update event, and trigger the callback function.\n * However from this event we don't know whether it's text or image, no real data is returned.\n * Use with listenToClipboard function.\n * @param cb callback\n * @returns unlisten function\n */\nfunction onClipboardUpdate(cb) {\n    return listen(MONITOR_UPDATE_EVENT, cb);\n}\nasync function onTextUpdate(cb) {\n    return await listen(TEXT_CHANGED, (event) => {\n        const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n        cb(text);\n    });\n}\n/**\n * Listen to clipboard update event and get the updated types in a callback.\n * This listener tells you what types of data are updated.\n * This relies on `listenToClipboard()` who emits events this function listens to.\n * You can run `listenToClipboard()` or `startListening()` before calling this function.\n * When HTML is copied, this will be passed to callback: {files: false, image: false, html: true, rtf: false, text: true}\n * @param cb\n * @returns\n */\nfunction onSomethingUpdate(cb) {\n    return listen(SOMETHING_CHANGED, (event) => {\n        cb(event.payload);\n    });\n}\nfunction onHTMLUpdate(cb) {\n    return listen(HTML_CHANGED, (event) => {\n        const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n        cb(text);\n    });\n}\nfunction onRTFUpdate(cb) {\n    return listen(RTF_CHANGED, (event) => {\n        const text = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n        cb(text);\n    });\n}\nfunction onFilesUpdate(cb) {\n    return listen(FILES_CHANGED, (event) => {\n        const files = v.parse(ClipboardChangedFilesPayloadSchema, event.payload).value;\n        cb(files);\n    });\n}\nfunction onImageUpdate(cb) {\n    return listen(IMAGE_CHANGED, (event) => {\n        const base64ImageStr = v.parse(ClipboardChangedPayloadSchema, event.payload).value;\n        cb(base64ImageStr);\n    });\n}\nfunction onImageBinaryUpdate(cb) {\n    return listen(IMAGE_BINARY_CHANGED, (event) => {\n        cb(v.parse(ClipboardBinaryChangedPayloadSchema, event.payload).value);\n    });\n}\n/**\n * Used to check the status of clipboard monitor\n * @returns Whether the monitor is running\n */\nfunction isMonitorRunning() {\n    return invoke(IS_MONITOR_RUNNING_COMMAND).then((res) => v.parse(v.boolean(), res));\n}\n/**\n * Start running mointor thread in Tauri core. This feature is added in v0.5.x.\n * Before v0.5.x, the monitor is started during setup when app starts.\n * After v0.5.x, this function must be called first to start monitor.\n * After monitor is started, events \"plugin:clipboard://clipboard-monitor/update\" will be emitted when there is clipboard update.\n * \"plugin:clipboard://clipboard-monitor/status\" event is also emitted when monitor status updates\n * Still have to listen to these events.\n */\nfunction startMonitor() {\n    return invoke(START_MONITOR_COMMAND);\n}\n/**\n * Stop clipboard monitor thread.\n */\nfunction stopMonitor() {\n    return invoke(STOP_MONITOR_COMMAND);\n}\n/**\n * Listen to monitor status update. Instead of calling isMonitorRunning to get status of monitor,\n * \"plugin:clipboard://clipboard-monitor/status\" event is emitted from Tauri core when monitor status updates.\n * @param cb callback to be called when there is monitor status update\n */\nasync function listenToMonitorStatusUpdate(cb) {\n    return await listen(CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT, (event) => {\n        const newStatus = v.parse(v.boolean(), event.payload);\n        cb(newStatus);\n    });\n}\nfunction startListening(listenTypes = {\n    text: true,\n    html: true,\n    rtf: true,\n    image: true,\n    imageBinary: false,\n    files: true\n}) {\n    return startMonitor()\n        .then(() => listenToClipboard(listenTypes))\n        .then((unlistenClipboard) => {\n        // return an unlisten function that stop listening to clipboard update and stop the monitor\n        return async () => {\n            unlistenClipboard();\n            await stopMonitor();\n        };\n    });\n}\n\nvar api = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AVAILABLE_TYPES_COMMAND: AVAILABLE_TYPES_COMMAND,\n    CLEAR_COMMAND: CLEAR_COMMAND,\n    CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT: CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT,\n    ClipboardBinaryChangedPayloadSchema: ClipboardBinaryChangedPayloadSchema,\n    ClipboardChangedFilesPayloadSchema: ClipboardChangedFilesPayloadSchema,\n    ClipboardChangedPayloadSchema: ClipboardChangedPayloadSchema,\n    FILES_CHANGED: FILES_CHANGED,\n    HAS_FILES_COMMAND: HAS_FILES_COMMAND,\n    HAS_HTML_COMMAND: HAS_HTML_COMMAND,\n    HAS_IMAGE_COMMAND: HAS_IMAGE_COMMAND,\n    HAS_RTF_COMMAND: HAS_RTF_COMMAND,\n    HAS_TEXT_COMMAND: HAS_TEXT_COMMAND,\n    HTML_CHANGED: HTML_CHANGED,\n    IMAGE_BINARY_CHANGED: IMAGE_BINARY_CHANGED,\n    IMAGE_CHANGED: IMAGE_CHANGED,\n    IS_MONITOR_RUNNING_COMMAND: IS_MONITOR_RUNNING_COMMAND,\n    MONITOR_UPDATE_EVENT: MONITOR_UPDATE_EVENT,\n    READ_FILES_COMMAND: READ_FILES_COMMAND,\n    READ_FILES_URIS_COMMAND: READ_FILES_URIS_COMMAND,\n    READ_HTML_COMMAND: READ_HTML_COMMAND,\n    READ_IMAGE_BASE64_COMMAND: READ_IMAGE_BASE64_COMMAND,\n    READ_IMAGE_BINARY_COMMAND: READ_IMAGE_BINARY_COMMAND,\n    READ_RTF_COMMAND: READ_RTF_COMMAND,\n    READ_TEXT_COMMAND: READ_TEXT_COMMAND,\n    RTF_CHANGED: RTF_CHANGED,\n    SOMETHING_CHANGED: SOMETHING_CHANGED,\n    START_MONITOR_COMMAND: START_MONITOR_COMMAND,\n    STOP_MONITOR_COMMAND: STOP_MONITOR_COMMAND,\n    TEXT_CHANGED: TEXT_CHANGED,\n    WRITE_FILES_COMMAND: WRITE_FILES_COMMAND,\n    WRITE_FILES_URIS_COMMAND: WRITE_FILES_URIS_COMMAND,\n    WRITE_HTML_AND_TEXT_COMMAND: WRITE_HTML_AND_TEXT_COMMAND,\n    WRITE_HTML_COMMAND: WRITE_HTML_COMMAND,\n    WRITE_IMAGE_BASE64_COMMAND: WRITE_IMAGE_BASE64_COMMAND,\n    WRITE_IMAGE_BINARY_COMMAND: WRITE_IMAGE_BINARY_COMMAND,\n    WRITE_RTF_COMMAND: WRITE_RTF_COMMAND,\n    WRITE_TEXT_COMMAND: WRITE_TEXT_COMMAND,\n    clear: clear,\n    convertIntArrToUint8Array: convertIntArrToUint8Array,\n    convertUint8ArrayToBlob: convertUint8ArrayToBlob,\n    getAvailableTypes: getAvailableTypes,\n    hasFiles: hasFiles,\n    hasHTML: hasHTML,\n    hasImage: hasImage,\n    hasRTF: hasRTF,\n    hasText: hasText,\n    isMonitorRunning: isMonitorRunning,\n    listenToClipboard: listenToClipboard,\n    listenToMonitorStatusUpdate: listenToMonitorStatusUpdate,\n    onClipboardUpdate: onClipboardUpdate,\n    onFilesUpdate: onFilesUpdate,\n    onHTMLUpdate: onHTMLUpdate,\n    onImageBinaryUpdate: onImageBinaryUpdate,\n    onImageUpdate: onImageUpdate,\n    onRTFUpdate: onRTFUpdate,\n    onSomethingUpdate: onSomethingUpdate,\n    onTextUpdate: onTextUpdate,\n    readFiles: readFiles,\n    readFilesURIs: readFilesURIs,\n    readHtml: readHtml,\n    readImageBase64: readImageBase64,\n    readImageBinary: readImageBinary,\n    readImageObjectURL: readImageObjectURL,\n    readRtf: readRtf,\n    readText: readText,\n    startBruteForceImageMonitor: startBruteForceImageMonitor,\n    startBruteForceTextMonitor: startBruteForceTextMonitor,\n    startListening: startListening,\n    startMonitor: startMonitor,\n    stopMonitor: stopMonitor,\n    writeFiles: writeFiles,\n    writeFilesURIs: writeFilesURIs,\n    writeHtml: writeHtml,\n    writeHtmlAndText: writeHtmlAndText,\n    writeImageBase64: writeImageBase64,\n    writeImageBinary: writeImageBinary,\n    writeRtf: writeRtf,\n    writeText: writeText\n});\n\nexport { AVAILABLE_TYPES_COMMAND, CLEAR_COMMAND, CLIPBOARD_MONITOR_STATUS_UPDATE_EVENT, ClipboardBinaryChangedPayloadSchema, ClipboardChangedFilesPayloadSchema, ClipboardChangedPayloadSchema, FILES_CHANGED, HAS_FILES_COMMAND, HAS_HTML_COMMAND, HAS_IMAGE_COMMAND, HAS_RTF_COMMAND, HAS_TEXT_COMMAND, HTML_CHANGED, IMAGE_BINARY_CHANGED, IMAGE_CHANGED, IS_MONITOR_RUNNING_COMMAND, MONITOR_UPDATE_EVENT, READ_FILES_COMMAND, READ_FILES_URIS_COMMAND, READ_HTML_COMMAND, READ_IMAGE_BASE64_COMMAND, READ_IMAGE_BINARY_COMMAND, READ_RTF_COMMAND, READ_TEXT_COMMAND, RTF_CHANGED, SOMETHING_CHANGED, START_MONITOR_COMMAND, STOP_MONITOR_COMMAND, TEXT_CHANGED, WRITE_FILES_COMMAND, WRITE_FILES_URIS_COMMAND, WRITE_HTML_AND_TEXT_COMMAND, WRITE_HTML_COMMAND, WRITE_IMAGE_BASE64_COMMAND, WRITE_IMAGE_BINARY_COMMAND, WRITE_RTF_COMMAND, WRITE_TEXT_COMMAND, clear, convertIntArrToUint8Array, convertUint8ArrayToBlob, api as default, getAvailableTypes, hasFiles, hasHTML, hasImage, hasRTF, hasText, isMonitorRunning, listenToClipboard, listenToMonitorStatusUpdate, onClipboardUpdate, onFilesUpdate, onHTMLUpdate, onImageBinaryUpdate, onImageUpdate, onRTFUpdate, onSomethingUpdate, onTextUpdate, readFiles, readFilesURIs, readHtml, readImageBase64, readImageBinary, readImageObjectURL, readRtf, readText, startBruteForceImageMonitor, startBruteForceTextMonitor, startListening, startMonitor, stopMonitor, writeFiles, writeFilesURIs, writeHtml, writeHtmlAndText, writeImageBase64, writeImageBinary, writeRtf, writeText };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}