{"ast":null,"code":"import { __classPrivateFieldGet, __classPrivateFieldSet } from './external/tslib/tslib.es6.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nvar _Channel_onmessage, _Channel_nextMessageIndex, _Channel_pendingMessages, _Channel_messageEndIndex, _Resource_rid;\n/**\n * Invoke your custom commands.\n *\n * This package is also accessible with `window.__TAURI__.core` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * A key to be used to implement a special function\n * on your types that define how your type should be serialized\n * when passing across the IPC.\n * @example\n * Given a type in Rust that looks like this\n * ```rs\n * #[derive(serde::Serialize, serde::Deserialize)\n * enum UserId {\n *   String(String),\n *   Number(u32),\n * }\n * ```\n * `UserId::String(\"id\")` would be serialized into `{ String: \"id\" }`\n * and so we need to pass the same structure back to Rust\n * ```ts\n * import { SERIALIZE_TO_IPC_FN } from \"@tauri-apps/api/core\"\n *\n * class UserIdString {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { String: this.id }\n *   }\n * }\n *\n * class UserIdNumber {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { Number: this.id }\n *   }\n * }\n *\n * type UserId = UserIdString | UserIdNumber\n * ```\n *\n */\n// if this value changes, make sure to update it in:\n// 1. ipc.js\n// 2. process-ipc-message-fn.js\nconst SERIALIZE_TO_IPC_FN = '__TAURI_TO_IPC_KEY__';\n/**\n * Stores the callback in a known location, and returns an identifier that can be passed to the backend.\n * The backend uses the identifier to `eval()` the callback.\n *\n * @return An unique identifier associated with the callback function.\n *\n * @since 1.0.0\n */\nfunction transformCallback(\n// TODO: Make this not optional in v3\ncallback) {\n  let once = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return window.__TAURI_INTERNALS__.transformCallback(callback, once);\n}\nclass Channel {\n  constructor(onmessage) {\n    _Channel_onmessage.set(this, void 0);\n    // the index is used as a mechanism to preserve message order\n    _Channel_nextMessageIndex.set(this, 0);\n    _Channel_pendingMessages.set(this, []);\n    _Channel_messageEndIndex.set(this, void 0);\n    __classPrivateFieldSet(this, _Channel_onmessage, onmessage || (() => {}), \"f\");\n    this.id = transformCallback(rawMessage => {\n      const index = rawMessage.index;\n      if ('end' in rawMessage) {\n        if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n          this.cleanupCallback();\n        } else {\n          __classPrivateFieldSet(this, _Channel_messageEndIndex, index, \"f\");\n        }\n        return;\n      }\n      const message = rawMessage.message;\n      // Process the message if we're at the right order\n      if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n        __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n        __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n        // process pending messages\n        while (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") in __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")) {\n          const message = __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n          __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n          // eslint-disable-next-line @typescript-eslint/no-array-delete\n          delete __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n          __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n        }\n        if (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") === __classPrivateFieldGet(this, _Channel_messageEndIndex, \"f\")) {\n          this.cleanupCallback();\n        }\n      }\n      // Queue the message if we're not\n      else {\n        // eslint-disable-next-line security/detect-object-injection\n        __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[index] = message;\n      }\n    });\n  }\n  cleanupCallback() {\n    window.__TAURI_INTERNALS__.unregisterCallback(this.id);\n  }\n  set onmessage(handler) {\n    __classPrivateFieldSet(this, _Channel_onmessage, handler, \"f\");\n  }\n  get onmessage() {\n    return __classPrivateFieldGet(this, _Channel_onmessage, \"f\");\n  }\n  [(_Channel_onmessage = new WeakMap(), _Channel_nextMessageIndex = new WeakMap(), _Channel_pendingMessages = new WeakMap(), _Channel_messageEndIndex = new WeakMap(), SERIALIZE_TO_IPC_FN)]() {\n    return `__CHANNEL__:${this.id}`;\n  }\n  toJSON() {\n    // eslint-disable-next-line security/detect-object-injection\n    return this[SERIALIZE_TO_IPC_FN]();\n  }\n}\nclass PluginListener {\n  constructor(plugin, event, channelId) {\n    this.plugin = plugin;\n    this.event = event;\n    this.channelId = channelId;\n  }\n  async unregister() {\n    return invoke(`plugin:${this.plugin}|remove_listener`, {\n      event: this.event,\n      channelId: this.channelId\n    });\n  }\n}\n/**\n * Adds a listener to a plugin event.\n *\n * @returns The listener object to stop listening to the events.\n *\n * @since 2.0.0\n */\nasync function addPluginListener(plugin, event, cb) {\n  const handler = new Channel(cb);\n  return invoke(`plugin:${plugin}|registerListener`, {\n    event,\n    handler\n  }).then(() => new PluginListener(plugin, event, handler.id));\n}\n/**\n * Get permission state for a plugin.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function checkPermissions(plugin) {\n  return invoke(`plugin:${plugin}|check_permissions`);\n}\n/**\n * Request permissions.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function requestPermissions(plugin) {\n  return invoke(`plugin:${plugin}|request_permissions`);\n}\n/**\n * Sends a message to the backend.\n * @example\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });\n * ```\n *\n * @param cmd The command name.\n * @param args The optional arguments to pass to the command.\n * @param options The request options.\n * @return A promise resolving or rejecting to the backend response.\n *\n * @since 1.0.0\n */\nasync function invoke(cmd) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let options = arguments.length > 2 ? arguments[2] : undefined;\n  return window.__TAURI_INTERNALS__.invoke(cmd, args, options);\n}\n/**\n * Convert a device file path to an URL that can be loaded by the webview.\n * Note that `asset:` and `http://asset.localhost` must be added to [`app.security.csp`](https://v2.tauri.app/reference/config/#csp-1) in `tauri.conf.json`.\n * Example CSP value: `\"csp\": \"default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost\"` to use the asset protocol on image sources.\n *\n * Additionally, `\"enable\" : \"true\"` must be added to [`app.security.assetProtocol`](https://v2.tauri.app/reference/config/#assetprotocolconfig)\n * in `tauri.conf.json` and its access scope must be defined on the `scope` array on the same `assetProtocol` object.\n *\n * @param  filePath The file path.\n * @param  protocol The protocol to use. Defaults to `asset`. You only need to set this when using a custom protocol.\n * @example\n * ```typescript\n * import { appDataDir, join } from '@tauri-apps/api/path';\n * import { convertFileSrc } from '@tauri-apps/api/core';\n * const appDataDirPath = await appDataDir();\n * const filePath = await join(appDataDirPath, 'assets/video.mp4');\n * const assetUrl = convertFileSrc(filePath);\n *\n * const video = document.getElementById('my-video');\n * const source = document.createElement('source');\n * source.type = 'video/mp4';\n * source.src = assetUrl;\n * video.appendChild(source);\n * video.load();\n * ```\n *\n * @return the URL that can be used as source on the webview.\n *\n * @since 1.0.0\n */\nfunction convertFileSrc(filePath) {\n  let protocol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asset';\n  return window.__TAURI_INTERNALS__.convertFileSrc(filePath, protocol);\n}\n/**\n * A rust-backed resource stored through `tauri::Manager::resources_table` API.\n *\n * The resource lives in the main process and does not exist\n * in the Javascript world, and thus will not be cleaned up automatiacally\n * except on application exit. If you want to clean it up early, call {@linkcode Resource.close}\n *\n * @example\n * ```typescript\n * import { Resource, invoke } from '@tauri-apps/api/core';\n * export class DatabaseHandle extends Resource {\n *   static async open(path: string): Promise<DatabaseHandle> {\n *     const rid: number = await invoke('open_db', { path });\n *     return new DatabaseHandle(rid);\n *   }\n *\n *   async execute(sql: string): Promise<void> {\n *     await invoke('execute_sql', { rid: this.rid, sql });\n *   }\n * }\n * ```\n */\nclass Resource {\n  get rid() {\n    return __classPrivateFieldGet(this, _Resource_rid, \"f\");\n  }\n  constructor(rid) {\n    _Resource_rid.set(this, void 0);\n    __classPrivateFieldSet(this, _Resource_rid, rid, \"f\");\n  }\n  /**\n   * Destroys and cleans up this resource from memory.\n   * **You should not call any method on this object anymore and should drop any reference to it.**\n   */\n  async close() {\n    return invoke('plugin:resources|close', {\n      rid: this.rid\n    });\n  }\n}\n_Resource_rid = new WeakMap();\nfunction isTauri() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n  return !!(globalThis || window).isTauri;\n}\nexport { Channel, PluginListener, Resource, SERIALIZE_TO_IPC_FN, addPluginListener, checkPermissions, convertFileSrc, invoke, isTauri, requestPermissions, transformCallback };","map":{"version":3,"names":["__classPrivateFieldGet","__classPrivateFieldSet","_Channel_onmessage","_Channel_nextMessageIndex","_Channel_pendingMessages","_Channel_messageEndIndex","_Resource_rid","SERIALIZE_TO_IPC_FN","transformCallback","callback","once","arguments","length","undefined","window","__TAURI_INTERNALS__","Channel","constructor","onmessage","set","id","rawMessage","index","cleanupCallback","message","call","unregisterCallback","handler","WeakMap","toJSON","PluginListener","plugin","event","channelId","unregister","invoke","addPluginListener","cb","then","checkPermissions","requestPermissions","cmd","args","options","convertFileSrc","filePath","protocol","Resource","rid","close","isTauri","globalThis"],"sources":["C:/Users/lhaveman/email-generator/node_modules/@tauri-apps/api/core.js"],"sourcesContent":["import { __classPrivateFieldGet, __classPrivateFieldSet } from './external/tslib/tslib.es6.js';\n\n// Copyright 2019-2024 Tauri Programme within The Commons Conservancy\n// SPDX-License-Identifier: Apache-2.0\n// SPDX-License-Identifier: MIT\nvar _Channel_onmessage, _Channel_nextMessageIndex, _Channel_pendingMessages, _Channel_messageEndIndex, _Resource_rid;\n/**\n * Invoke your custom commands.\n *\n * This package is also accessible with `window.__TAURI__.core` when [`app.withGlobalTauri`](https://v2.tauri.app/reference/config/#withglobaltauri) in `tauri.conf.json` is set to `true`.\n * @module\n */\n/**\n * A key to be used to implement a special function\n * on your types that define how your type should be serialized\n * when passing across the IPC.\n * @example\n * Given a type in Rust that looks like this\n * ```rs\n * #[derive(serde::Serialize, serde::Deserialize)\n * enum UserId {\n *   String(String),\n *   Number(u32),\n * }\n * ```\n * `UserId::String(\"id\")` would be serialized into `{ String: \"id\" }`\n * and so we need to pass the same structure back to Rust\n * ```ts\n * import { SERIALIZE_TO_IPC_FN } from \"@tauri-apps/api/core\"\n *\n * class UserIdString {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { String: this.id }\n *   }\n * }\n *\n * class UserIdNumber {\n *   id\n *   constructor(id) {\n *     this.id = id\n *   }\n *\n *   [SERIALIZE_TO_IPC_FN]() {\n *     return { Number: this.id }\n *   }\n * }\n *\n * type UserId = UserIdString | UserIdNumber\n * ```\n *\n */\n// if this value changes, make sure to update it in:\n// 1. ipc.js\n// 2. process-ipc-message-fn.js\nconst SERIALIZE_TO_IPC_FN = '__TAURI_TO_IPC_KEY__';\n/**\n * Stores the callback in a known location, and returns an identifier that can be passed to the backend.\n * The backend uses the identifier to `eval()` the callback.\n *\n * @return An unique identifier associated with the callback function.\n *\n * @since 1.0.0\n */\nfunction transformCallback(\n// TODO: Make this not optional in v3\ncallback, once = false) {\n    return window.__TAURI_INTERNALS__.transformCallback(callback, once);\n}\nclass Channel {\n    constructor(onmessage) {\n        _Channel_onmessage.set(this, void 0);\n        // the index is used as a mechanism to preserve message order\n        _Channel_nextMessageIndex.set(this, 0);\n        _Channel_pendingMessages.set(this, []);\n        _Channel_messageEndIndex.set(this, void 0);\n        __classPrivateFieldSet(this, _Channel_onmessage, onmessage || (() => { }), \"f\");\n        this.id = transformCallback((rawMessage) => {\n            const index = rawMessage.index;\n            if ('end' in rawMessage) {\n                if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n                    this.cleanupCallback();\n                }\n                else {\n                    __classPrivateFieldSet(this, _Channel_messageEndIndex, index, \"f\");\n                }\n                return;\n            }\n            const message = rawMessage.message;\n            // Process the message if we're at the right order\n            if (index == __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")) {\n                __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n                // process pending messages\n                while (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") in __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")) {\n                    const message = __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n                    __classPrivateFieldGet(this, _Channel_onmessage, \"f\").call(this, message);\n                    // eslint-disable-next-line @typescript-eslint/no-array-delete\n                    delete __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\")];\n                    __classPrivateFieldSet(this, _Channel_nextMessageIndex, __classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") + 1, \"f\");\n                }\n                if (__classPrivateFieldGet(this, _Channel_nextMessageIndex, \"f\") === __classPrivateFieldGet(this, _Channel_messageEndIndex, \"f\")) {\n                    this.cleanupCallback();\n                }\n            }\n            // Queue the message if we're not\n            else {\n                // eslint-disable-next-line security/detect-object-injection\n                __classPrivateFieldGet(this, _Channel_pendingMessages, \"f\")[index] = message;\n            }\n        });\n    }\n    cleanupCallback() {\n        window.__TAURI_INTERNALS__.unregisterCallback(this.id);\n    }\n    set onmessage(handler) {\n        __classPrivateFieldSet(this, _Channel_onmessage, handler, \"f\");\n    }\n    get onmessage() {\n        return __classPrivateFieldGet(this, _Channel_onmessage, \"f\");\n    }\n    [(_Channel_onmessage = new WeakMap(), _Channel_nextMessageIndex = new WeakMap(), _Channel_pendingMessages = new WeakMap(), _Channel_messageEndIndex = new WeakMap(), SERIALIZE_TO_IPC_FN)]() {\n        return `__CHANNEL__:${this.id}`;\n    }\n    toJSON() {\n        // eslint-disable-next-line security/detect-object-injection\n        return this[SERIALIZE_TO_IPC_FN]();\n    }\n}\nclass PluginListener {\n    constructor(plugin, event, channelId) {\n        this.plugin = plugin;\n        this.event = event;\n        this.channelId = channelId;\n    }\n    async unregister() {\n        return invoke(`plugin:${this.plugin}|remove_listener`, {\n            event: this.event,\n            channelId: this.channelId\n        });\n    }\n}\n/**\n * Adds a listener to a plugin event.\n *\n * @returns The listener object to stop listening to the events.\n *\n * @since 2.0.0\n */\nasync function addPluginListener(plugin, event, cb) {\n    const handler = new Channel(cb);\n    return invoke(`plugin:${plugin}|registerListener`, { event, handler }).then(() => new PluginListener(plugin, event, handler.id));\n}\n/**\n * Get permission state for a plugin.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function checkPermissions(plugin) {\n    return invoke(`plugin:${plugin}|check_permissions`);\n}\n/**\n * Request permissions.\n *\n * This should be used by plugin authors to wrap their actual implementation.\n */\nasync function requestPermissions(plugin) {\n    return invoke(`plugin:${plugin}|request_permissions`);\n}\n/**\n * Sends a message to the backend.\n * @example\n * ```typescript\n * import { invoke } from '@tauri-apps/api/core';\n * await invoke('login', { user: 'tauri', password: 'poiwe3h4r5ip3yrhtew9ty' });\n * ```\n *\n * @param cmd The command name.\n * @param args The optional arguments to pass to the command.\n * @param options The request options.\n * @return A promise resolving or rejecting to the backend response.\n *\n * @since 1.0.0\n */\nasync function invoke(cmd, args = {}, options) {\n    return window.__TAURI_INTERNALS__.invoke(cmd, args, options);\n}\n/**\n * Convert a device file path to an URL that can be loaded by the webview.\n * Note that `asset:` and `http://asset.localhost` must be added to [`app.security.csp`](https://v2.tauri.app/reference/config/#csp-1) in `tauri.conf.json`.\n * Example CSP value: `\"csp\": \"default-src 'self' ipc: http://ipc.localhost; img-src 'self' asset: http://asset.localhost\"` to use the asset protocol on image sources.\n *\n * Additionally, `\"enable\" : \"true\"` must be added to [`app.security.assetProtocol`](https://v2.tauri.app/reference/config/#assetprotocolconfig)\n * in `tauri.conf.json` and its access scope must be defined on the `scope` array on the same `assetProtocol` object.\n *\n * @param  filePath The file path.\n * @param  protocol The protocol to use. Defaults to `asset`. You only need to set this when using a custom protocol.\n * @example\n * ```typescript\n * import { appDataDir, join } from '@tauri-apps/api/path';\n * import { convertFileSrc } from '@tauri-apps/api/core';\n * const appDataDirPath = await appDataDir();\n * const filePath = await join(appDataDirPath, 'assets/video.mp4');\n * const assetUrl = convertFileSrc(filePath);\n *\n * const video = document.getElementById('my-video');\n * const source = document.createElement('source');\n * source.type = 'video/mp4';\n * source.src = assetUrl;\n * video.appendChild(source);\n * video.load();\n * ```\n *\n * @return the URL that can be used as source on the webview.\n *\n * @since 1.0.0\n */\nfunction convertFileSrc(filePath, protocol = 'asset') {\n    return window.__TAURI_INTERNALS__.convertFileSrc(filePath, protocol);\n}\n/**\n * A rust-backed resource stored through `tauri::Manager::resources_table` API.\n *\n * The resource lives in the main process and does not exist\n * in the Javascript world, and thus will not be cleaned up automatiacally\n * except on application exit. If you want to clean it up early, call {@linkcode Resource.close}\n *\n * @example\n * ```typescript\n * import { Resource, invoke } from '@tauri-apps/api/core';\n * export class DatabaseHandle extends Resource {\n *   static async open(path: string): Promise<DatabaseHandle> {\n *     const rid: number = await invoke('open_db', { path });\n *     return new DatabaseHandle(rid);\n *   }\n *\n *   async execute(sql: string): Promise<void> {\n *     await invoke('execute_sql', { rid: this.rid, sql });\n *   }\n * }\n * ```\n */\nclass Resource {\n    get rid() {\n        return __classPrivateFieldGet(this, _Resource_rid, \"f\");\n    }\n    constructor(rid) {\n        _Resource_rid.set(this, void 0);\n        __classPrivateFieldSet(this, _Resource_rid, rid, \"f\");\n    }\n    /**\n     * Destroys and cleans up this resource from memory.\n     * **You should not call any method on this object anymore and should drop any reference to it.**\n     */\n    async close() {\n        return invoke('plugin:resources|close', {\n            rid: this.rid\n        });\n    }\n}\n_Resource_rid = new WeakMap();\nfunction isTauri() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n    return !!(globalThis || window).isTauri;\n}\n\nexport { Channel, PluginListener, Resource, SERIALIZE_TO_IPC_FN, addPluginListener, checkPermissions, convertFileSrc, invoke, isTauri, requestPermissions, transformCallback };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}